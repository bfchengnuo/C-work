百度文库地址：

http://wenku.baidu.com/view/04906bbb1a37f111f1855bfb.html?qq-pf-to=pcqq.group

IEEE-754 浮点数转换（临时版）

地址：http://justjavac.com/tools/ieee-754-floating-point-conversion-from-floating-point-to-hexadecimal.html


-----------------------------分割线-------------------------------------
整数的表示
 
对于十进制的整数，如果有效数字不太多，则是可以精确表示的。比如100 表示为(-1)0×1.1001×26 。
 
但是如果有效数字太多，则可能会出问题。比如对于12 345 678 901 234 567 000，即使使用了double（binary64）来表示，结果为1.010 101 101 010 100 101 010 011 000 110 011 101 011 000 111 110 000 1×263，但这个二进制表示其实代表的却是1.234 567 890 123 456 7e19。
 
小数0.6如何表示？
 
对于整数，二进制表示只会丢失有效数字，而不会有其他的编号。然而对于小数，则可能会很麻烦，因为小数的二进制表示可能是无限循环的。
 
比如，对于0.6,的binary64表示：
(0.6)10 = (0.100 110 011 001 100 110 011 001 100 110 011 001 100 110 011 001 100 110 011 001 100 1...)2
            = (1.001 100 110 011 001 100 110 011 001 100 110 011 001 100 110 011 001 100 110 011 001...)2×2-1
 
于是，符号位s=0，指数e为-1，有效数字为1.001 100 110 011 001 100 110 011 001 100 110 011 001 100 110 011 001 100 110 011 001...
 
我们知道，binary64的有效数字最多有53位，也就是说
1.001 100 110 011 001 100 110 011 001 100 110 011 001 100 110 011 001 1//00 110 011 001... //的黄色部分(已标注)需要被抛弃。
 
那么我们应该如何抛弃这部分数据呢？在IEEE中规定了若干舍入方法，一般来说，普遍使用的是roundTiesToEven方式来舍入。
 
roundTiesToEven方法：round到相邻的浮点数据上。如果两个浮点数据都一样近，
则round到最后一位是偶数的浮点数据上。
 
由此,0.6~=(-1)0×1.001 100 110 011 001 100 110 011 001 100 110 011 001 100 110 011 001 1×2-1。

原文地址：http://thihy.iteye.com/blog/1867577